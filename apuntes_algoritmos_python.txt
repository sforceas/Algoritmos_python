apuntes_algoritmos_python.txt

1.  Programación orientada a objetos en Python

    Uso de clases para organizar programas en modulos y abstracciones de datos
    En este curso se usan clases orientadas a objetos.
    Objeto: agrupación de datos y métodos que operan esos datos.

    Las clases permiten crear nuevos "tipos" de datos que contienen información arbitraria sobre un objeto.
    Las clases solo proveen la estructura para construir objetos. Señalan las propiedades del objeto, pero no son ninguno en concreto.
    
    Para crear objetos especificos se usan Instancias.

    - Clases: formulario 
    - Instancias: cada copia rellena de datos del formulario

    Pueden existir varias instancias diferentes que pertenezcan a la misma clase.
    para definir una clase se usa el keyword : class.
    
    Ejemplo
            class Hotel:
                <atributos>
            hotel1 = Hotel(<atributos>)
    
    Ejemplo: clases_hotel.py

    Atributos de instancia: son las caracteristicas de cada objeto(instancia) creado a partir de una clase.
    Se usa el método especial "def__init__" para definir los atributos. Se definen con el parámetro self.<nombre_atributo> = <nombre_variable>

    Ejemplo:
            class Hotel:

                def __init__ (self,valorA,valorB):
                    self.valorA = numeroA
                    self.valorB = numeroB
            hotel1 = Hotel (numeroA=1,numeroB=2)

    Métodos de instancia: realizan operaciones con los atributos de la clase. Equivalen a funciones dentro de la definicion de la clase y reciben self. como primer argumento.

    Ejemplo:

            class Hotel:
            ...
            def añadir_valorC(self,numeroC)
                self.valorC += numeroC #suma a valorC el numeroC (suma: +=, resta -=)

Decomposición: partir un problema en partes mas sencillos que son clases.
    Ejemplo: decomposicion.txt

Abstracción: enfocarnos en la informacion relevante
Separa info central (variables publicos) de detalles secundarios (_variables_privadas)
La interfaz con el usuario requiere de variables y métodos PUBLICOS, pero si no le interesa se pone en privado con el _metodo
    Ejemplo: abstracciones.py

Ecampsulación: agrupar datos y comportamiento en un mismo lugar importante en el Defensive Programing para proteger el acceso y modificacion de los datos.
 Se usan los gerretrs: @property y setter: @nombre_atributo.setter antes de sus respectivas funciones.

 
    Ejemplo: encapsulacion.py


Herencia: nos permite modelar una jerarquia de objetos y compartir cierto comportamiento. Ayuda a organizar codigo. Los atributos de una superclase se hereedan a las subclase, permitiendo especializar cada subclase
 SUPERCLASE 
    |____SUBCLASE1
    |        |____SUB-___SUBCLASE1
    |
    |____SUBCLASE2

    Ejemplo: herencia.py
             herencia_celulas.py
            
Polimorfismos:
 En computación, polimorfismo describe el concepto de que objetos de diferentes tupos pueden ser accedidos a través de la misma interfaz. Dicho de otra forma, es la habilidad de procesar objetos de forma distinta dependiendo de su tipo de dato o clase. Esto es la habilidad redefinir métodos para clases derivadas.
 Por ejemplo, dada la clase forma, el polimorfismo le permite al programador definir métodos para encontrar el área según la clase derivada, sea circulo,    rectángulos, cuadrados, etc. Sin importar que forma sea el objeto, el área debería poder hallar el resultado correcto si se aplica el polimorfismo correctamente.

 • En el dinámico la creación del objeto ocurre en el run-time. Se le conoce también como ‘late-binding’ o ‘method overriding’ en diferentes clases (sobre escritura de método)
 • En el caso del estático ocurre en el compile-time. Se le conoce también como ‘early binding’ o method overloading en diferentes clases (sobrecarga de métodos)
 Python sin embargo no soporta la sobrecarga de métodos por default, por lo que no es tan necesario tener en cuenta estos tipos de polimorfismo.   
    Ejemplo: polimorfismos.py



**** Clases de complejidad algoritmica ***
 Existen distintos tipos de complejidad algorítmica:

 O(1) Constante: no importa la cantidad de input que reciba, siempre demorara el mismo tiempo.
 O(n) Lineal: la complejidad crecerá de forma proporcional a medida que crezca el input.
 O(log n) Logarítmica: nuestra función crecerá de forma logarítmica con respecto al input. Esto significa que en un inicio crecerá rápido, pero luego se estabilizara.
 O(n log n) Log lineal: crecerá de forma logarítmica pero junto con una constante.
 O(n²) Polinomial: crecen de forma cuadrática. No son recomendables a menos que el input de datos en pequeño.
 O(2^n) Exponencial: crecerá de forma exponencial, por lo que la carga es muy alta. Para nada recomendable en ningún caso, solo para análisis conceptual.
 O(n!) Factorial: crece de forma factorial, por lo que al igual que el exponencial su carga es muy alta, por lo que jamas utilizar algoritmos de este tipo.

**** Algoritmo de Busqueda Lineal ****
 Buscar elementos en una lista. 
 
    Ejemplo:  busqueda_lineal.py
    
**** Algoritmo de Busqueda Lineal ****
 Buscar elementos en una lista ORDENADA de la forma mas eficiente. usar la función lista_ordenada = sort(lista_desordenada).
 
    Ejemplo:  busqueda_lineal.py

**** Ordenamiento de burbuja ****

 El primer algoritmo de ordenamiento que veremos es el ordenamiento de burbuja. Es un algoritmo que recorre repetidamente una lista que necesita ordenarse. Compara elementos adyacentes y los intercambia si están en el orden incorrecto. Este procedimiento se repite hasta que no se requiere mas intercambios, lo que indica que la lista se encuentra ordenada. 
    Ejembplo: ordenamiento_burbuja.py

**** Ordenamiento por interción *****
 El ordenamiento por inserción es uno de los algoritmos más comunes que estudian
 los Científicos del Cómputo. Es intuitivo y fácil de implementar, pero es muy
 ineficiente para listas de gran tamaño.

 Una de las características del ordenamiento por inserción es que ordena en “su
 lugar.” Es decir, no requiere memoria adicional para realizar el ordenamiento
 ya que simplemente modifican los valores en memoria.

    Ejemplo: ordenamiento_insercion.py 

**** Ordenamiento por mezcla (merge sort) ****
 Inventado por J.F. Newman. Ordenamiento muy eficiente n*log(n)
  Ejemplo: ordenamiento_mezcla

**** Ambientes virtuales *****
 Es importante usar ambientes virtuales para cada proyecto y así evitar contaminar el pc con librerias instaladas directamente. Estas librerias se pueden usar mediante el comando pip install (ver webstore de pip). 
 
 Para crear un ambiente virtual, donde se instalaran las librerias únicamente para ese proyecto se inicia en la terminal con el comando:
    
    python3.8 -m venv <nombre_del_ambiente_virtual>  # Crea el ambiente virtual
    source env/bin/activate # Inicializa el ambiente virtual.
    deactivate # Cierra el ambiente virtual
    pip install <nombre_de_libreria> # instala librerias
    pip3 install <nombre_de_libreria> #alternativa para terminal zsh



***** Graficado de datos ******
 Libreria "bokeh" --> pip3 install bokeh
 bokeh nos permite exportar a formatos html, notebooks, imagenes etc. Tambien compatible con API y Django. docs.bokeh.org

 Ejemplo:
    graficado_bokeh.py

 Libreria "pandas" --> pip install pandas
 pandas permite trabajar, importa y exportar archivos de datos (csv) de manera muy intuitiva.
 
 Ejemplo:
    ensayo_traccion.py
