apuntes_algoritmos_python.txt

1.  Programación orientada a objetos en Python

    Uso de clases para organizar programas en modulos y abstracciones de datos
    En este curso se usan clases orientadas a objetos.
    Objeto: agrupación de datos y métodos que operan esos datos.

    Las clases permiten crear nuevos "tipos" de datos que contienen información arbitraria sobre un objeto.
    Las clases solo proveen la estructura para construir objetos. Señalan las propiedades del objeto, pero no son ninguno en concreto.
    
    Para crear objetos especificos se usan Instancias.

    - Clases: formulario 
    - Instancias: cada copia rellena de datos del formulario

    Pueden existir varias instancias diferentes que pertenezcan a la misma clase.
    para definir una clase se usa el keyword : class.
    
    Ejemplo
            class Hotel:
                <atributos>
            hotel1 = Hotel(<atributos>)
    
    Ejemplo: clases_hotel.py

    Atributos de instancia: son las caracteristicas de cada objeto(instancia) creado a partir de una clase.
    Se usa el método especial "def__init__" para definir los atributos. Se definen con el parámetro self.<nombre_atributo> = <nombre_variable>

    Ejemplo:
            class Hotel:

                def __init__ (self,valorA,valorB):
                    self.valorA = numeroA
                    self.valorB = numeroB
            hotel1 = Hotel (numeroA=1,numeroB=2)

    Métodos de instancia: realizan operaciones con los atributos de la clase. Equivalen a funciones dentro de la definicion de la clase y reciben self. como primer argumento.

    Ejemplo:

            class Hotel:
            ...
            def añadir_valorC(self,numeroC)
                self.valorC += numeroC #suma a valorC el numeroC (suma: +=, resta -=)

Decomposición: partir un problema en partes mas sencillos que son clases.
    Ejemplo: decomposicion.txt

Abstracción: enfocarnos en la informacion relevante
Separa info central (variables publicos) de detalles secundarios (_variables_privadas)
La interfaz con el usuario requiere de variables y métodos PUBLICOS, pero si no le interesa se pone en privado con el _metodo
    Ejemplo: abstracciones.py

Ecampsulación: agrupar datos y comportamiento en un mismo lugar importante en el Defensive Programing para proteger el acceso y modificacion de los datos.
 Se usan los gerretrs: @property y setter: @nombre_atributo.setter antes de sus respectivas funciones.

 
    Ejemplo: encapsulacion.py


Herencia: nos permite modelar una jerarquia de objetos y compartir cierto comportamiento. Ayuda a organizar codigo. Los atributos de una superclase se hereedan a las subclase, permitiendo especializar cada subclase
 SUPERCLASE 
    |____SUBCLASE1
    |        |____SUB-___SUBCLASE1
    |
    |____SUBCLASE2

    Ejemplo: herencia.py
             herencia_celulas.py
            
Polimorfismos:
 En computación, polimorfismo describe el concepto de que objetos de diferentes tupos pueden ser accedidos a través de la misma interfaz. Dicho de otra forma, es la habilidad de procesar objetos de forma distinta dependiendo de su tipo de dato o clase. Esto es la habilidad redefinir métodos para clases derivadas.
 Por ejemplo, dada la clase forma, el polimorfismo le permite al programador definir métodos para encontrar el área según la clase derivada, sea circulo,    rectángulos, cuadrados, etc. Sin importar que forma sea el objeto, el área debería poder hallar el resultado correcto si se aplica el polimorfismo correctamente.

 • En el dinámico la creación del objeto ocurre en el run-time. Se le conoce también como ‘late-binding’ o ‘method overriding’ en diferentes clases (sobre escritura de método)
 • En el caso del estático ocurre en el compile-time. Se le conoce también como ‘early binding’ o method overloading en diferentes clases (sobrecarga de métodos)
 Python sin embargo no soporta la sobrecarga de métodos por default, por lo que no es tan necesario tener en cuenta estos tipos de polimorfismo.   
    Ejemplo: polimorfismos.py
